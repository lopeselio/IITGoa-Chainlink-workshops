// SPDX-License-Identifier: MIT
pragma solidity 0.8.6;

// Step 1: importing Chainlink Automation contracts and Counters library 
import "@chainlink/contracts/src/v0.8/KeeperCompatible.sol";
import "@openzeppelin/contracts@4.6.0/token/ERC721/extensions/ERC721URIStorage.sol";
import "@openzeppelin/contracts@4.6.0/utils/Counters.sol";

// Step2: add the `AutomationCompatibleInterface` contract as an imported contract
contract DynamicNFT is ERC721, ERC721URIStorage, KeeperCompatibleInterface {

// Step3: Next, under the contract definition, we’re going to define a new `Counters` variable. This variable will track at which stage of the flower the NFT is at

    using Counters for Counters.Counter;
    Counters.Counter public tokenIdCounter;
// Step 4: add a string array that stores all the metadata for each stage of the dynamic NFT. For this NFT we have three different states possible
    string[] IpfsUri = [
        "https://ipfs.io/ipfs/QmYaTsyxTDnrG4toc8721w62rL4ZBKXQTGj9c9Rpdrntou/seed.json",
        "https://ipfs.io/ipfs/QmYaTsyxTDnrG4toc8721w62rL4ZBKXQTGj9c9Rpdrntou/purple-sprout.json",
        "https://ipfs.io/ipfs/QmYaTsyxTDnrG4toc8721w62rL4ZBKXQTGj9c9Rpdrntou/purple-blooms.json"
    ]; 

// Step 5: create a couple of variables to define the current time, and time since the NFT was last updated or checked

    uint256 lastTimeStamp;
    uint256 interval;

// Step 6: . The constructor should take the `interval` value in seconds, then should store it, and the lastTimeStamp should be set to the current chain's latest timestamp. 
    constructor(uint _interval) ERC721("Flower IITGoa", "fBCN") {
        interval = _interval;
        lastTimeStamp = block.timestamp;
    }

// Step 7: The next step is to add the Chainlink Automation specific functions under the constructor, `checkUpkeep` and `performUpkeep`. CheckUpkeep will be used to check if an update to the NFT should occur, and performUpkeep will actually modify the NFT
  function checkUpkeep(bytes calldata /* checkData */) external view override returns (bool upkeepNeeded, bytes memory /* performData */) {
        uint256 tokenId = tokenIdCounter.current() - 1;
        bool done;
        if (flowerStage(tokenId) >= 2) {
            done = true;
        }

        upkeepNeeded = !done && ((block.timestamp - lastTimeStamp) > interval);        
        // We don't use the checkData in this example. The checkData is defined when the Upkeep was registered.
    }
    
    function performUpkeep(bytes calldata /* performData */) external override {
        //We highly recommend revalidating the upkeep in the performUpkeep function
        if ((block.timestamp - lastTimeStamp) > interval ) {
            lastTimeStamp = block.timestamp;            
            uint256 tokenId = tokenIdCounter.current() - 1;
            growFlower(tokenId);
        }
        // We don't use the performData in this example. The performData is generated by the Keeper's call to your checkUpkeep function
    }

// Step 8: The next step is to replace the contents of the ‘safeMint’ function generated, with the code below:
    function safeMint(address to) public {
        uint256 tokenId = tokenIdCounter.current();
        tokenIdCounter.increment();
        _safeMint(to, tokenId);
        _setTokenURI(tokenId, IpfsUri[0]);
    }

// Step 9: Now that we have our Automation functions, the next step is to add a function that gets called by the performUpkeep function. This function will contain the logic to switch the NFT URI depending on the state of the NFT. So it will start with stage 1 (seedling), then when Chainlink Automation network updates the NFT again, the URI will get updated to the spouting URI, and then when the function is called for a third time, the final stage for the NFT will be the bloom URI
    function growFlower(uint256 _tokenId) public {
        if(flowerStage(_tokenId) >= 2){return;}
        // Get the current stage of the flower and add 1
        uint256 newVal = flowerStage(_tokenId) + 1;
        // store the new URI
        string memory newUri = IpfsUri[newVal];
        // Update the URI
        _setTokenURI(_tokenId, newUri);
    }

// Step 10: we will add two helper functions that the `growFlower` will use to help determine what stage of the NFT the URI currently is (0, 1 or 2), and a function to help compare strings in Solidity
    // determine the stage of the flower growth
    function flowerStage(uint256 _tokenId) public view returns (uint256) {
        string memory _uri = tokenURI(_tokenId);
        // Seed
        if (compareStrings(_uri, IpfsUri[0])) {
            return 0;
        }
        // Sprout
        if (
            compareStrings(_uri, IpfsUri[1]) 
        ) {
            return 1;
        }
        // Must be a Bloom
        return 2;
    }

    // helper function to compare strings
    function compareStrings(string memory a, string memory b)
        public
        pure
        returns (bool)
    {
        return (keccak256(abi.encodePacked((a))) ==
            keccak256(abi.encodePacked((b))));
    }

    // The following functions is an override required by Solidity.
    function _burn(uint256 tokenId)
        internal
        override(ERC721, ERC721URIStorage)
    {
        super._burn(tokenId);
    }

    // The following functions is an override required by Solidity.
    function tokenURI(uint256 tokenId)
        public
        view
        override(ERC721, ERC721URIStorage)
        returns (string memory)
    {
        return super.tokenURI(tokenId);
    }
}
